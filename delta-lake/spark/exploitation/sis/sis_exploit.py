import os
import duckdb
from datetime import datetime

# Paths
tz_db = os.path.abspath('/data/trusted/databases/trusted_data.db')
exploit_db = os.path.abspath('/data/exploitation/databases/exploitation.db')

# Connect to exploitation DB (will create if not exists)
conn = duckdb.connect(exploit_db)

# Attach trusted zone database
conn.execute(f"""
ATTACH DATABASE '{tz_db}' AS trusted;
""")

conn.execute("DROP TABLE IF EXISTS cohort_students")
# 1) cohort_students: include graduation year or drop out year
conn.execute("""
CREATE OR REPLACE TABLE cohort_students AS
WITH 
first_year AS (
  SELECT student_id,
         MIN(CAST(SPLIT_PART(academic_year, ' - ', 1) AS INTEGER)) AS cohort_year
  FROM trusted.trusted_student_enrollment
  WHERE "year" = 1
  GROUP BY student_id
),
graduated AS (
  SELECT student_id,
         CAST(SPLIT_PART(graduation_year, ' - ', 2) AS INTEGER) as grad_year
  FROM trusted.trusted_graduations
), 
dropped AS(
    SELECT student_id,
           CAST(SPLIT_PART(dropout_year, ' - ', 2) AS INTEGER) as dropout_year
    FROM trusted.trusted_dropouts
)

SELECT
    fy.student_id, 
    fy.cohort_year,
    g.grad_year,
    d.dropout_year, 
    CASE
        WHEN g.grad_year IS NOT NULL THEN 'graduated'
        WHEN d.dropout_year IS NOT NULL THEN 'droped out'
        ELSE 'active'
    END AS status
FROM first_year fy
LEFT JOIN graduated g on fy.student_id = g.student_id
LEFT JOIN dropped d on fy.student_id = d.student_id
ORDER BY fy.cohort_year, g.grad_year, d.dropout_year;
""")

#2 cohort_sizes from cohort_students
conn.execute("DROP TABLE IF EXISTS cohort_sizes")
conn.execute("""
CREATE OR REPLACE TABLE cohort_sizes AS
SELECT cohort_year,
       COUNT(*) AS cohort_size
FROM cohort_students
GROUP BY cohort_year
ORDER BY cohort_year;
""")

# determine max end-year across all graduations
max_grad_year = conn.execute("""
  SELECT MAX(
    CAST(SPLIT_PART(graduation_year, ' - ', 2) AS INTEGER)
  ) FROM trusted.trusted_graduations;
""").fetchone()[0]

# compute cohort cutoffs
limit_4 = max_grad_year - 4
limit_5 = max_grad_year - 5
limit_6 = max_grad_year - 6

# 3) graduation_rates for 4-6 years 
conn.execute("DROP TABLE IF EXISTS graduation_rates")
conn.execute(f"""
CREATE OR REPLACE TABLE graduation_rates AS
SELECT
  cohort_year,
  COUNT(*) FILTER (
    WHERE grad_year IS NOT NULL
      AND grad_year <= cohort_year + 4
      AND cohort_year <= {limit_4}
  )::DOUBLE / COUNT(*)   AS grad_4yr_rate,
  COUNT(*) FILTER (
    WHERE grad_year IS NOT NULL
      AND grad_year <= cohort_year + 5
      AND cohort_year <= {limit_5}
  )::DOUBLE / COUNT(*)   AS grad_5yr_rate,
  COUNT(*) FILTER (
    WHERE grad_year IS NOT NULL
      AND grad_year <= cohort_year + 6
      AND cohort_year <= {limit_6}
  )::DOUBLE / COUNT(*)   AS grad_6yr_rate
FROM cohort_students
GROUP BY cohort_year
ORDER BY cohort_year;
""")

# 4) Retention rates 
conn.execute("DROP TABLE IF EXISTS retention_rates")
conn.execute(f"""
CREATE OR REPLACE TABLE retention_rates AS
WITH total_enrollment AS (
    SELECT cohort_year, COUNT(student_id) AS total_enroll
    FROM cohort_students
    GROUP BY cohort_year
),
drop_per_year AS (
    SELECT 
        te.cohort_year, 
        te.total_enroll, 
        cs.dropout_year, 
        COUNT(cs.student_id) AS drop_in_year
    FROM cohort_students cs
    JOIN total_enrollment te
        ON cs.cohort_year = te.cohort_year
    WHERE cs.dropout_year IS NOT NULL
    GROUP BY te.cohort_year, te.total_enroll, cs.dropout_year
)
SELECT 
    dpy.cohort_year, 
    dpy.dropout_year,
    dpy.total_enroll, 
    ROUND(
        (dpy.total_enroll - SUM(dpy.drop_in_year) OVER (
            PARTITION BY dpy.cohort_year 
            ORDER BY dpy.dropout_year
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ))::FLOAT / dpy.total_enroll * 100,
        2
    ) AS retention_percent
FROM drop_per_year dpy
ORDER BY dpy.cohort_year, dpy.dropout_year;
""")

# 5) GPA (Per Dept maybe)
conn.execute("DROP TABLE IF EXISTS dept_gpa")
conn.execute(
'''
CREATE OR Replace TABLE dept_gpa AS
WITH course_enroll AS (
	SELECT student_id, course_code, grade, semester, ROW_NUMBER() OVER 
	(PARTITION BY student_id, course_code ORDER BY semester DESC) AS rownum FROM trusted.trusted_enrollment tc
),
latest_enroll AS (
	SELECT * FROM course_enroll WHERE  rownum=1
), 
all_gpa AS (
SELECT student_id , sum((grade*4/100) * credits)/sum(credits) AS gpa 
	FROM latest_enroll le, trusted.trusted_course tc
	WHERE le.course_code=tc.course_code AND grade IS NOT null
	GROUP by student_id
	ORDER BY student_id
)
SELECT major, major AS department, round(avg(gpa),2) AS rate FROM trusted.trusted_student_enrollment se, all_gpa
WHERE se.student_id=all_gpa.student_id
GROUP BY major
''')

# # 7) Average GPA (By course)
# conn.execute("DROP TABLE IF EXISTS avg_gpa_course")
# conn.execute(
# '''
# CREATE OR REPLACE TABLE avg_gpa_course AS
# WITH course_enroll AS (
# 	SELECT student_id, course_code, grade, semester, ROW_NUMBER() OVER 
# 	(PARTITION BY student_id, course_code ORDER BY semester DESC) AS rownum FROM trusted.trusted_enrollment tc
# ),
# latest_enroll AS (
# 	SELECT * FROM course_enroll WHERE  rownum=1
# )
# SELECT tc.course_code , round(avg(grade*4/100),2) AS gpa 
# 	FROM latest_enroll le, trusted.trusted_course tc
# 	WHERE le.course_code=tc.course_code AND grade IS NOT null
# 	GROUP by tc.course_code
# '''
# )

#7. 
'''
CREATE OR REPLACE TABLE total_students_all_years AS
WITH yearly_counts AS (
    SELECT cohort_year AS year, COUNT(*) AS student_count
    FROM cohort_students
    GROUP BY cohort_year
),
with_lag AS (
    SELECT
        year,
        student_count AS current_count,
        LAG(student_count) OVER (ORDER BY year) AS previous_count
    FROM yearly_counts
)
SELECT
    year,
    previous_count,
    current_count,
    CASE
        WHEN current_count > previous_count THEN 'increase'
        WHEN current_count < previous_count THEN 'decrease'
        ELSE 'no change'
    END AS state,
    ROUND(
        100.0 * ABS(current_count - previous_count) / NULLIF(previous_count, 0),
        2
    ) AS percent
FROM with_lag
WHERE previous_count IS NOT NULL;
''' 

#8
'''
CREATE OR REPLACE TABLE retention_hist_all_year AS
WITH final_y AS (
        SELECT academic_year, COUNT(DISTINCT student_id) AS num_year_4
        FROM trusted_student_enrollment
        WHERE YEAR = 4
        GROUP BY academic_year
    ),
    grad_y AS (
        SELECT graduation_year, COUNT(DISTINCT student_id) AS num_grad
        FROM trusted_graduations
        GROUP BY graduation_year
    )
    SELECT 
        CAST(SPLIT_PART(academic_year, ' - ', 2) AS INTEGER) AS year,
        ROUND(num_grad * 100.0 / num_year_4, 2) AS rate
    FROM grad_y gy
    JOIN final_y fy ON fy.academic_year = gy.graduation_year
    WHERE CAST(SPLIT_PART(academic_year, ' - ', 2) AS INTEGER) 
    ORDER BY academic_year;
'''

#9
'''
  
CREATE OR REPLACE TABLE graduation_hist_all_year AS
 WITH enroll_year AS (
    SELECT student_id, CAST(SPLIT_PART(academic_year, ' - ', 2) AS INTEGER) AS academic_enroll_year
    FROM trusted_student_enrollment
),
dropout_info AS (
    SELECT academic_enroll_year, tse.student_id, c.dropout_year
    FROM enroll_year tse
    LEFT JOIN cohort_students c ON c.student_id = tse.student_id
),
enroll AS (
    SELECT academic_enroll_year, COUNT(DISTINCT student_id) AS NStudentEnroll
    FROM enroll_year
    GROUP BY academic_enroll_year
),
not_drop AS (
    SELECT academic_enroll_year, COUNT(student_id) AS non_drop_num
    FROM dropout_info
    WHERE academic_enroll_year != dropout_year OR dropout_year IS NULL
    GROUP BY academic_enroll_year
)
SELECT 
    e.academic_enroll_year AS year,
    ROUND(non_drop_num * 100.0 / NStudentEnroll, 2) AS rate
FROM enroll e
JOIN not_drop nd ON e.academic_enroll_year = nd.academic_enroll_year
WHERE e.academic_enroll_year 
ORDER BY e.academic_enroll_year;

'''